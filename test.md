
## ../swiftlib-django/requirements.txt
```python

Django==2.1
isbnlib==3.9.9
mysqlclient==1.4.2.post1
pkg-resources==0.0.0
pytz==2019.1

```


## ../swiftlib-django/swiftlib/swiftlib/db_config.cnf
```python

[client]
NAME = 'swiftlib'
user = 'admin'
password = '0018'
host = 'localhost'

```


## ../swiftlib-django/swiftlib/swiftlib/urls.py
```python

from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static
from students.views import initial_setup

urlpatterns = [
    path('admin/', admin.site.urls),
    path('books/', include('books.urls')),
    path('students/', include('students.urls')),
    path('issues/', include('issues.urls')),
    path('', include('home.urls')),
] + static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)


# inital, one-time setup
initial_setup()

```


## ../swiftlib-django/swiftlib/swiftlib/settings.py
```python

"""
Django settings for swiftlib project.

Generated by 'django-admin startproject' using Django 2.1.

For more information on this file, see
https://docs.djangoproject.com/en/2.1/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/2.1/ref/settings/
"""

import os

# Build paths inside the project like this: os.path.join(BASE_DIR, ...)
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/2.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = '6vk$pocgjrin&4emm!qj+(miewj$kw&f@-2l!5-puz%)u0t@xr'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'books.apps.BooksConfig',
    'students.apps.StudentsConfig',
    'issues.apps.IssuesConfig',
    'home.apps.HomeConfig',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'swiftlib.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': ['swiftlib/templates', os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'swiftlib.wsgi.application'


# Database
# https://docs.djangoproject.com/en/2.1/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'swiftlib',
        'USER': 'admin',
        'PASSWORD': '270302',
        'HOST': 'localhost',
    }
}


# Password validation
# https://docs.djangoproject.com/en/2.1/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/2.1/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_L10N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/2.1/howto/static-files/

STATIC_URL = '/static/'
STATIC_ROOT = 'static/'

STATICFILES_DIRS = [
    'swiftlib/static',
]

LOGIN_URL = '/login/'

```


## ../swiftlib-django/swiftlib/home/urls.py
```python

from django.urls import path
from . import views

urlpatterns = [
    path('', views.home, name='home'),
    path('login/', views.app_login, name='login'),
    path('logout/', views.logout_view, name='logout'),
    path('add_user/', views.create_new_user, name='add-new-user'),

]

```


## ../swiftlib-django/swiftlib/home/views.py
```python

from django.shortcuts import render, redirect
from django.contrib import auth
from django.contrib.auth.models import User
from django.contrib.auth.decorators import login_required
from django.db.utils import IntegrityError

# Create your views here.

def send_success(request, message):
    context = {
        'success_message': message
        }
    return render(request, 'status.html', context)

def send_failure(request, message):
    context = {
        'failure_message': message
    }
    return render(request, 'status.html', context)


@login_required
def home(request):
    librarians = User.objects.all()
    return render(request, 'home/home.html', {'libs':librarians})

def app_login(request):
    if request.method == 'POST':
        # login 
        data = request.POST
        username = data['username']
        password = data['password']

        user1 = auth.authenticate(request, username=username, password=password)

        if user1 is not None:
            auth.login(request, user1)
            return redirect('home')

        elif user1 is None:
            context = {
                'error': "User Credentials Invalid"
                }
            return render(request, 'home/login.html', context)
    else:
        return render(request, 'home/login.html')

@login_required
def create_new_user(request):

    if request.method == 'POST':
        data = request.POST
        username = data['username']
        password1 = data['password1']
        password2 = data['password2']

        if password1 == password2:
            try:
                user = User.objects.create(username=username, password=password1)
            except IntegrityError:
                return send_failure(request, "User Already Exists!")

            message = "Librarian {username} successfully created!".format(username=user.username)
            return send_success(request, message)
        else:
            message = 'Passwords do not match!'
            return send_failure(request, message)
    else:
        return render(request, 'home/add-user.html')

@login_required
def logout_view(request):
    auth.logout(request)
    return redirect('login')

```


## ../swiftlib-django/swiftlib/home/admin.py
```python

from django.contrib import admin

# Register your models here.

```


## ../swiftlib-django/swiftlib/home/models.py
```python

from django.db import models

# Create your models here.

```


## ../swiftlib-django/swiftlib/students/urls.py
```python

from django.urls import path
from . import views

urlpatterns = [
    path('', views.home, name='students_home'),
    path('addstudent/', views.addstudent, name='students_add'),
    path('info/<str:pid>', views.studentinfo, name='students_info'),

]

```


## ../swiftlib-django/swiftlib/students/views.py
```python

from django.core.exceptions import ObjectDoesNotExist
from django.db import IntegrityError
from django.contrib.auth.models import User
from django.contrib.auth.decorators import login_required
from django.shortcuts import render
from .models import Student


def send_success(request, message):
    context = {
        'success_message': message
        }
    return render(request, 'status.html', context)


def send_failure(request, message):
    context = {
        'failure_message': message
        }
    return render(request, 'status.html', context)


# one-time function to setup default admin user
def initial_setup():
    try:
        admin_user = User.objects.get(username='admin', email='admin@swiftlib.com')
    except ObjectDoesNotExist:
        admin_user = User.objects.create_superuser(username='admin', email='admin@swiftlib.com', password='password')
        admin_user.save()

@login_required
def home(request):
    if request.method == 'POST':
        pass
    else:
        students = Student.objects.all()
        context = {
            'students': students,
        }
        return render(request, 'students/students.html', context)


@login_required
def addstudent(request):
    if request.method == 'POST':

        data = request.POST

        name = str(data.get('student-name'))
        pid = str(data.get('student-pid'))

        pid = pid.replace('/', '-')

        new_student = Student(
            name  = name,
            pid = pid
        )

        try:
            new_student.save()

        except IntegrityError:
            message = 'This student already exists!'
            return send_failure(request, message)

        message = "Student " + new_student.name + " with ID " + str(new_student.pid) + " successfully created!"
        return send_success(request, message)

    else:
        return render(request, 'students/student-add-form.html')


@login_required
def studentinfo(request, pid):
    if request.method == 'POST':
        data = request.POST
        pid = data['deletion_id']

        try:
            student_to_be_deleted = Student.objects.get(pid=pid)

        except IntegrityError:
            context = {
                'failure_message': "There is already a student with that ID!"
            }
            return render(request, 'status.html', context)

        except ObjectDoesNotExist:
            context = {
                'failure_message': "The Student you are attempting to Delete does not Exist!"
            }
            return render(request, 'status.html', context)

        student_to_be_deleted.delete()

        context = {
            'success_message': "Student " + str(pid) + " has been successfully deleted! "
        }

        return render(request, 'status.html', context)

    else:

        try:
            student = Student.objects.get(pid=pid)
            context = {
                'student': student,
            }
            return render(request,'students/student-info-form.html', context)

        except ObjectDoesNotExist:
            context = {
                'failure_message': 'Student does not exist!'
            }
            return render(request, 'status.html', context)

```


## ../swiftlib-django/swiftlib/students/admin.py
```python

from django.contrib import admin
from .models import Student
# Register your models here.

admin.site.register(Student)

```


## ../swiftlib-django/swiftlib/students/models.py
```python

from django.db import models
# Create your models here.

class Student(models.Model):
    name = models.CharField(max_length=100)
    book_issued = models.ForeignKey('books.Book', null=True, on_delete=models.DO_NOTHING)
    pid = models.CharField(max_length=20, unique=True)

    def __str__(self):
        return self.name

```


## ../swiftlib-django/swiftlib/issues/urls.py
```python

from django.urls import path
from. import views

urlpatterns = [
    path('', views.home, name='issues-home'),
    path('issue-book', views.issuebook, name='issuebook'),
    path('returnbooks/', views.returnbook, name='returnbook'),
    path('issueinfo/<int:issue_id>', views.issueinfo, name='issueinfo')
]

```


## ../swiftlib-django/swiftlib/issues/views.py
```python

from django.shortcuts import render
from django.db import IntegrityError
from django.core.exceptions import ObjectDoesNotExist
from datetime import datetime
from . import models as issues
from books import models as books
from students import models as students
from django.contrib.auth.decorators import login_required

def send_success(request, message):
    context = {
        'success_message': message
        }
    return render(request, 'status.html', context)

def send_failure(request, message):
    context = {
        'failure_message': message
        }
    return render(request, 'status.html', context)

def get_filtered(qset, criteria):
    if criteria == 'issued_only':
        return qset.filter(status = 'issued')
    elif criteria == 'returned_only':
        return qset.filter(status = 'returned')
    else:
        return qset

@login_required
def home(request):

    if request.method == 'POST':

        data = request.POST
        search_query = data['search_query']
        search_criteria = data['search_criteria']
        filter_criteria = data['filter_criteria']

        if search_criteria == 'book_isbn':
            # search for similar ISBN of book issued
            isbn = int(search_query)
            results = issues.Issue.objects.filter(book_issued__isbn13=isbn)
            results = get_filtered(results, filter_criteria)
            context = {
                'results': results,
                'has_results': True,
            }
            return render(request, 'issues/issues.html', context)

        if search_criteria == 'book_name':
            # search for similar name of book issued
            name = str(search_query)
            results = issues.Issue.objects.filter(book_issued__name__icontains=name)
            results = get_filtered(results, filter_criteria)
            context = {
                'results': results,
                'has_results': True,
            }
            return render(request, 'issues/issues.html', context)

        if search_criteria == 'student_name':
            # search for similar name of student to whom book is issued
            name = str(search_query)
            results = issues.Issue.objects.filter(user_issued__name__icontains=name)
            results = get_filtered(results, filter_criteria)
            context = {
                'results': results,
                'has_results': True,
            }
            return render(request, 'issues/issues.html', context)

        if search_criteria == 'student_id':
            pid = str(search_query)
            results = issues.Issue.objects.filter(user_issued__pid__icontains=pid)
            results = get_filtered(results, filter_criteria)
            context = {
                'results': results,
                'has_results': True,
            }
            return render(request, 'issues/issues.html', context)
    else:

        # default - show latest 5 issued books
        default = issues.Issue.objects.order_by('-date_issued')[:20]
        context = {
            'has_results': False,
            'default': default,
        }
        return render(request, 'issues/issues.html', context)


@login_required
def issuebook(request):
    if request.method == 'POST':

        data = request.POST
        student_pid = str(data['student-pid'])
        book_isbn = str(data['book-isbn'])

        student_to_issue_to = students.Student.objects.get(pid=student_pid)
        book_to_issue = books.Book.objects.get(isbn13=book_isbn)

        # check if the book has been issued toa student already
        try:
            check = students.Student.objects.get(book_issued = book_to_issue)
            if check is not None:
                return send_failure(request, "book has already been issued")
        except ObjectDoesNotExist:
            pass

        new_issue = issues.Issue(
            user_issued = student_to_issue_to,
            book_issued = book_to_issue,
            status = 'issued'
        )

        try:
            new_issue.save()
            student_to_issue_to.book_issued = book_to_issue
            student_to_issue_to.save()

        except IntegrityError:
            message = 'Book has already been issued'
            return send_failure(request, message)

        message = "Book "+ str(new_issue.book_issued) + " has been successfully Issued! "

        return send_success(request, message)

    else:
        return render(request, 'issues/issues-add-form.html')

@login_required
def returnbook(request):
    if request.method == 'POST':

        now = datetime.today().strftime('%Y-%m-%d')

        data = request.POST

        student_pid = str(data['student-pid'])
        book_isbn = str(data['book-isbn'])

        student_issue = students.Student.objects.get(pid=student_pid)
        book_issue = books.Book.objects.get(isbn13=book_isbn)

        try:
            check = students.Student.objects.get(book_issued = book_issue)
        except ObjectDoesNotExist:
            return send_failure(request, "Book has not been issued to anyone")

        return_book = issues.Issue.objects.get(
            user_issued = student_issue,
            book_issued = book_issue,
            status = 'issued'
            )

        try:
            return_book.date_returned = now
            return_book.status = 'returned'
            return_book.save()
            student_issue.book_issued = None
            student_issue.save()

        except:
            message = 'Book could not be returned'
            return send_failure(request,message)
        message = "Book "+ str(return_book.book_issued) + " has been successfully Returned! "
        return send_success(request, message)
    else:
        return render(request, 'issues/issues-return-form.html')

def issueinfo(request, issue_id):
    #TODO - Add this method and set up modals for search results
    try:
        issue = issues.Issue.objects.get(id=issue_id)
        context = {'issue': issue}
        return render(request, 'issues/issues-info-form.html', context)

    except ObjectDoesNotExist:
        return send_failure(request, "The Issue you are looking for does not exist")

```


## ../swiftlib-django/swiftlib/issues/admin.py
```python

from django.contrib import admin
from . import models 
# Register your models here.
admin.site.register(models.Issue)

```


## ../swiftlib-django/swiftlib/issues/models.py
```python

from django.db import models

class Issue(models.Model):

    status_options = [('issued', 'ISSUED'),
                       ('returned', 'RETURNED')]

    user_issued = models.ForeignKey('students.Student', on_delete=models.CASCADE)
    book_issued = models.ForeignKey('books.Book', on_delete=models.CASCADE)
    date_issued = models.DateField(auto_now_add=True)
    date_returned = models.DateField(blank=True,null=True)
    status = models.CharField(max_length=8, choices= status_options, default='issued')

    def __str__(self):
        return str(self.user_issued)  + " borrowed " +  str(self.book_issued)

```


## ../swiftlib-django/swiftlib/books/urls.py
```python

from django.urls import path
from . import views

urlpatterns = [
    path('', views.home, name='books-home'),
    path('addbooks/', views.addbook, name='addbook'),
    path('isvalidISBN/', views.isValidISBN, name='validate_isbn'),
    path('bookinfo/<int:isbn13>', views.getbookinfo, name='bookinfo'),
]

```


## ../swiftlib-django/swiftlib/books/libs.py
```python

import isbnlib
import isbnlib._exceptions as exceptions
import isbnlib.dev._exceptions as goob_exceptions


def getBookData(isbn13):
    try:
        data = isbnlib.meta(str(isbn13), service='goob')
    except exceptions.NotValidISBNError:
        return False
    except goob_exceptions.NoDataForSelectorError:
        return False

    name = data['Title']
    author = data['Authors'][0]
    isbn13 = data['ISBN-13']

    return [name, author, isbn13]

```


## ../swiftlib-django/swiftlib/books/views.py
```python

from django.core.exceptions import ObjectDoesNotExist
from django.db import IntegrityError

from django.contrib.auth.decorators import login_required
from django.shortcuts import render
from django.http import JsonResponse

from .models import Book
from .libs import getBookData

import json

def send_success(request, message):
    context = {
        'success_message': message
        }
    return render(request, 'status.html', context)

def send_failure(request, message):
    context = {
        'failure_message': message
        }
    return render(request, 'status.html', context)

def validateISBN(isbn):
    return str(''.join([x for x in isbn if x.isdigit()]))

# Create your views here.

@login_required
def home(request):
    if request.method == "POST" :
        pass
    else:
        books= Book.objects.all()
        context={
            'books' : books,
        }
    return render(request, 'books/books.html',context)

@login_required
def addbook(request):
    if request.method == 'POST':

        # get all POST data from page - data submitted in form
        data = request.POST

        # reference relevant parameters
        name = str(data.get('name'))
        isbn13 = str(data.get('isbn13'))
        author=str(data.get('author'))

        isbn13 = validateISBN(isbn13)

           # package a new Book object
        new_book = Book(
            name  = name,
            isbn13=isbn13,
            author=author
        )

        # save the new object
        try:
            new_book.save()

        # check if the book already exists
        except IntegrityError:
            message = 'Book already exists'
            return send_failure(request, message)

        # package success data

        message="Book "+ new_book.name + " added! "

        return send_success(request, message)

    else:
        # user wants to add data / is not reaching before any operation
        return render(request, 'books/add-book-form.html')

@login_required
def isValidISBN(request):
    if request.method == 'GET':
        data = request.GET
        isbn = data['isbn']
        isbn = validateISBN(isbn)

        data = getBookData(isbn)

        if data is False:
            return JsonResponse({'status':'failure'}) 
        else:
            return_data = {
                'status': 'found',
                'isbn13': data[2],
                'name': data[0],
                'author': data[1]
            }
            return JsonResponse(return_data)

@login_required
def getbookinfo(request, isbn13):
    if request.method == 'POST':

        data = request.POST
        isbn13 = data['delete-isbn']

        try:
            book_to_be_deleted = Book.objects.get(isbn13=isbn13)

        except ObjectDoesNotExist:
            context = {
                'failure_message': "The Book you are attempting to Delete does not Exist!"
            }
            return render(request, 'status.html', context)

        book_to_be_deleted.delete()

        context = {
            'success_message': "Book " + str(isbn13) + " has been successfully deleted! "
        }

        return render(request, 'status.html', context)

    else:

        try:
            books = Book.objects.get(isbn13=isbn13)
            context = {
                'book': books,
            }
            return render(request,'books/book-info-form.html', context)

        except ObjectDoesNotExist:
            message = 'Book does not exist'
        return send_failure(request, message)

    context = {
                'failure_message': 'Book does not exist!'
            }
    return render(request, 'status.html', context)

```


## ../swiftlib-django/swiftlib/books/admin.py
```python

from django.contrib import admin
from .models import Book
# Register your models here.

admin.site.register(Book)

```


## ../swiftlib-django/swiftlib/books/models.py
```python

from django.db import models

# Create your models here

class Book(models.Model):
    # defining book model

    name = models.CharField(max_length=252)
    author = models.CharField(max_length=252,null=True)
    isbn13 = models.CharField(max_length=13, blank=True, unique=True)

    # book pretty name
    def __str__(self):
        return self.name +' by ' + self.author

```


## ../swiftlib-django/README.md
```python

# Swiftlib - Lightweight library management system 
###### by Sharmistha , Mitul and Anirudh

```

